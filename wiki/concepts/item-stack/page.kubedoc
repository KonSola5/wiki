>>> warn
This page was created with KubeJS 7.2 (for 1.21.1) in mind. Most of the information you see here will work with your version as well, but code syntax especially might *slightly* differ across versions.

We are working on creating alternate versions of this page for other versions of Minecraft.
<<<

An `ItemStack` is an item associated with an amount and optionally some data attached to it.
Or to put it slightly differently, it is... well, *a single stack* of items that all share the same data. It is also the representation of an "item" that is most familiar to players, since item stacks are what you hold in your inventory, pick up from the ground, etc.

You may consider the `Item` contained in an `ItemStack` to basically just be the raw "definition" of what that item is.
For example, all Diamond Axes share the same item ID `minecraft:diamond_axe`, they all use the same item, but two Diamond Axes with different amounts of damage in your inventory, like `minecraft:diamond_axe[damage=123]` and `minecraft:diamond_axe[damage=456]` would be part of different **item stacks** since their data doesn't overlap.
Similarly, two sticks with custom lore `minecraft:stick[lore=[{text:"This Stick is very sticky."}]]` would work as part of the same item stack.

>>> quote
Since 1.20.4, data on items has changed *significantly* with the transition from NBT to data components. A neat side effect of this is that you can now change and override things that used to be hardcoded into the item definition itself, like the item's max stack size, enchantability, repair ingredients, etc.
<<<

# Creating ItemStacks

KubeJS will automatically try to *wrap* any input to an item stack in places where it is expected, but you can also use the `Item` wrapper ([[/ref/ItemWrapper|reference]]) to explicitly create them yourself, specifically using `[js]Item.of(input)` and `[js]Item.of(input, count)`:

Most ItemStacks can be simply written as string literals.

- `''` (empty string), `'-'`, `'air'` and `'minecraft:air'` will return an empty ItemStack. It doesn't seem particularly useful, but hey, it's there!
- Any item ID will create an ItemStack of that specific item.  
You can find item IDs easily by either enabling *advanced tooltips* in your game (press F3+H) and hovering over the item in your inventory, or by using the ever-useful [[/tutorials/hand|`/kubejs hand`]]!
	- Example: `[js]Item.of('minecraft:apple')`
- Prepending the item ID with an integer number and a letter `x` will create an item stack, with the stack size equal to the specified integer number.
  - Example: `[js]Item.of('2x minecraft:apple')`
- An item ID followed by a component (using the same syntax as [`/give`](https://minecraft.wiki/w/Argument_types#item_stack)) creates an item stack of the given item with the given components
	- Example: `[js]Item.of('minecraft:diamond_sword[damage=2]')`

You can of course, combine these syntaxes:
- `[js]Item.of('3x minecraft:stick[lore=[{text:"This Stick is very sticky."}]])'` will result a stack of three very sticky sticks (with custom data components!)

Also note that while possible in some older versions of KubeJS, [[/concepts/ingredient|`Ingredient`]]s are **unsupported** and WILL now error if you try to convert them to an ItemStack implicitly. If you want to explicitly convert an `Ingredient` into an `ItemStack`, use `ingredient.first`!

# Using ItemStacks

## Useful Methods and Properties
- `[js]item.getBlock()`:
  - **Returns**: The associated `Block` is the item corresponds to a block (that is - is an instance of `BlockItem`), otherwise `null`.
>>>info
Also available as a **read-only** bean: `item.block`.
<<<
- `[js]item.count` - Accessor for the stack size of the item.
>>>info
Also available as a getter `[js]item.setCount(count)` and setter `[js]item.getCount()`.
<<<
- `[js]item.grow(amount)`
  - `amount` - Specifies, by how much should the stack size be increased.
  - Returns nothing (`undefined`).

- `[js]item.shrink(amount)`
  - `amount` - Specifies, by how much should the stack size be decreased.
  - Returns nothing (`undefined`).

- `[js]item.withCount(count)`
  - `count` - The stack size of the new item stack.
  - **Returns** - A copy of the `item` with stack size of `count`.

- `[js]item.areItemsEqual(other)`:
  - `other`: An `ItemStack` to compare to.
  - **Returns** `true` if `item` and `other` relate to the same item type, `false` otherwise.

- `[js]item.areComponentsEqual(other)`: 
  - `other`: An `ItemStack` to compare to.
  - **Returns** `true` if `item` and `other` relate to the same item and have **identical components**, `false` otherwise.

## Registry Object Functions
These functions are all inherited from `Item`.
Described here will be **read-only** beans, but be aware that for the `x` bean, `getX()` getter exists.

- `[js]item.id`: Gets the item's ID in the item registry (as a string)
- `[js]item.idLocation`: Gets the item's ID in the item registry (as a `ResourceLocation`)
- `[js]item.key`: Gets the item's ID in the item registry (as a `ResourceKey<Item>`)
- `[js]item.mod`: Gets the **namespace** of an item.
  - For example, for `item` being `minecraft:stone`, `item.mod` will be `minecraft`.

- `[js]item.holder`: Gets the item wrapped into a Holder (internal registry object).
- `[js]item.registry`: Gets the item registry.
- `[js]item.registryId`: Gets the *key* of the item registry
- `[js]item.tags`: Gets a list of all tags for this item, as `ResourceLocation` objects.
- `[js]item.tagKeys`: Gets a list of all tags for this item, as `TagKey` objects.

- `[js]item.hasTag(tag)`: Checks if this item has a certain tag.
  - `tag` - A `ResourceLocation` or a string corresponding to a tag (for example `minecraft:logs`).
  - **Returns**: `true` if the item has `tag` as a tag, `false` otherwise.

## Component Functions
WIP! (TODO: make a page on Components and KubeJS' ComponentFunctions interface)
- `[js]item.components`: Gets a `DataComponentMap` (a map of item's components) of the item.
- `[js]item.componentString`: Gets a stringified representation of the item's components.

- `[js]item.enchantments`: Retrieves the item's enchantments, as an `ItemEnchantments` object.
- `[js]item.hasEnchantment(enchantment, level)`:
  - `enchantment`: The enchantment to check for. It may be a string representing an enchantment (like `minecraft:efficiency`).
  - `level`: The level to compare to.
  - **Returns**: `true` if the item has the given enchantment at a given level or higher, `false` otherwise.
- `[js]item.enchant(enchantment, level)`:
  - `enchantment`: The enchantment to check for. It may be a string representing an enchantment (like `minecraft:efficiency`).
  - `level`: The level of the enchantment
  - **Returns**: A copy of `item` with the enchantment applied. Only enchantments that were not present on the `item` already or that were below the level applied will be changed.
- `[js]item.enchant(enchantments)`:
  - `enchantments`: The enchantments to apply. It may be an object with keys being strings representing enchantments and values being the levels of enchantments.
  - **Returns**: A copy of `item` with the enchantments applied. Only enchantments that were not present on the `item` already or that were below the level applied will be changed.
  - Example:  
  ```js
	const enchItem = item.enchant({
		"minecraft:efficiency": 5,
		"minecraft:unbreaking": 3,
		"minecraft:mending": 1
	})
	// Will result in a copy of an item with the following enchantments applied:
	// Efficiency V, Unbreaking III, Mending
  ```
 
- `[js]item.getHarvestSpeed()`:
- `[js]item.getHarvestSpeed(block)`:
  - `block` #[[#z\51565D|\[Optional\]]]: The `Block` to check the harvest speed against.
  - **Returns**: The harvest speed of the item against a given block, or its default harvest speed if `block` isn't provided.
- `[js]item.toItemString()`:
  - **Returns**: A KubeJS string representation of an ItemStack.  
  Essentially does the reverse of an item wrapper, for example:
  For an `item` being a stack of 64 Sand, `[js]item.toItemString()` returns `[js]'64x minecraft:sand'`. 
- `[js]item.asIngredient()`
  - **Returns**: An `Ingredient` which matches the `item`.

- `[js]item.withCustomName(name)`: 
  - `name` - A text `Component` to apply as custom name. It may be a plain string, for example: `[js]'My custom item!'`
  - **Returns**: A copy of `item` with `minecraft:custom_name` data component applied.
- `[js]withLore(lore)`: Copies this item stack with the specified lore text
  - `lore` - An **array** of text `Component`s to apply as lore. Components in the array may be plain strings, for example: `[js]\['Some cool lore!', 'KubeJS rocks!'\]`
  - **Returns**: A copy of `item` with `minecraft:lore` data component applied.

- `[js]typeData`: ??? (is this just a custom map for scripters to use to attach data to item definitions?)
# Further Reading
- [Data Components](/concepts/data-components)
